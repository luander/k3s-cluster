apiVersion: helm.cattle.io/v1
kind: HelmChart
metadata:
  name: fluxcd
  namespace: kube-system
spec:
  targetNamespace: flux
  chart: flux
  repo: https://charts.fluxcd.io
  valuesContent: |-


    affinity: 
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
            - matchExpressions:
                - key: beta.kubernetes.io/arch
                  operator: In
                  values:
                    - amd64

    git:
      # URL of git repo with Kubernetes manifests; e.g. git.url=ssh://git@github.com/fluxcd/flux-get-started
      url: "git@github.com:luander/kube-flux.git"
      # Branch of git repo to use for Kubernetes manifests
      branch: "master"
      # Path within git repo to locate Kubernetes manifests (relative path)
      path: "cluster"
      # Set to `true` if you intend for Flux to not be able to push changes to git.
      # Also configure state.mode to `secret` since storing state in a git tag will no longer be possible.
      readonly: false
      # Username to use as git committer
      user: "Weave Flux"
      # Email to use as git committer
      email: "support@weave.works"
      # If set, commits will be signed with this GPG key.
      signingKey: ""
      # If set, the signatures of the sync tag and commits will be verified.
      verifySignatures: false
      # If set, the author of git commits will reflect the user who initiated the commit and will differ from the git committer.
      setAuthor: false
      # Label to keep track of sync progress
      label:
      # Append "[ci skip]" to commit messages so that CI will skip builds
      ciSkip: false
      # Period at which to poll git repo for new commits
      pollInterval: "5m"
      # Duration after which git operations time out
      timeout: "20s"
      # The secret name can be used to supply your own SSH key, instead of
      # relying on Flux to generate one for you:
      # 1. Generate a SSH key named identity:
      #      ssh-keygen -q -N "" -f ./identity
      # 2. Create a Kubernetes secret:
      #      kubectl -n flux create secret generic flux-ssh --from-file=./identity
      #   2a. The SSH key will be stored in a data key matching the file name.
      #       Set the `git.secretDataKey` value below to change the data key if
      #       you want to use a different source file.
      # 3. Don't check these key files into your Git repository! Once you've created
      #    the Kubernetes secret, Delete the private key:
      #      rm ./identity
      # 4. Add ./identity.pub as a deployment key with write access in your Git repo
      # 5. Set the secret name (flux-ssh) below
      secretName: ""
      # The default secret data key for storing the Git repository deploy key
      # is "identity" which must match the filename in the steps for supplying
      # your own SSH deploy key (see secretName above).  Use this field if you
      # want to use your own filename and override the key above.
      secretDataKey: ""
      # Enables `git-secret` support, as this makes use of known GPG keys
      # you will need to have imported the paired secret-key with one of
      # the public-keys which were used in the encryption using
      # `gpgKeys.secretName`.
      secret:
        enabled: false
      # Global Git configuration See https://git-scm.com/docs/git-config for more details.
      config:
        enabled: false
        secretName: ""
        data: ""
        # data: |
        #   [credential "https://github.com"]
        #           username = foo

    # # If `true` SOPS support will be enabled
    # sops:
    #   enabled: false

    # registry:
    #   # Period at which to check for updated images
    #   automationInterval: "5m"
    #   # Maximum registry requests per second per host
    #   rps: 200
    #   # Maximum number of warmer connections to remote and memcache
    #   burst: 125
    #   # Output trace of image registry requests to log
    #   trace: false
    #   # Use HTTP rather than HTTPS for these image registry domains eg --set registry.insecureHosts="registry1.cluster.local\,registry2.cluster.local"
    #   insecureHosts:
    #   # Duration to keep cached image info. Must be < 1 month. (Deprecated)
    #   cacheExpiry:
    #   # Disable registry scanning completely
    #   disableScanning: false
    #   # Do not scan images that match these glob expressions
    #   excludeImage:
    #   # Only scan images that match these glob expressions
    #   includeImage:
    #   # Allow usage of (RFC3339) timestamp labels from (canonical) image refs that match these glob expressions
    #   useTimestampLabels:
    #   # AWS ECR settings
    #   ecr:
    #     region:
    #     includeId:
    #     excludeId:
    #     require: false
    #   # Azure ACR settings
    #   acr:
    #     enabled: false
    #     hostPath: /etc/kubernetes/azure.json
    #     secretName: ""
    #   dockercfg:
    #     enabled: false
    #     secretName: ""
    #     configFileName: /dockercfg/config.json

    # memcached:
    #   enabled: true
    #   hostnameOverride:
    #   repository: memcached
    #   tag: 1.5.20
    #   pullSecret:
    #   createClusterIP: true
    #   verbose: false
    #   maxItemSize: 5m
    #   maxMemory: 512
    #   addSecurityContext: true
    #   securityContext:
    #     runAsUser: 11211
    #     runAsGroup: 11211
    #     allowPrivilegeEscalation: false
    #   nodeSelector: {}
    #   tolerations: []
    #   affinity: {}
    #   resources:
    #     # If you do want to specify resource limits, uncomment the following and adjust values
    #     # limits:
    #     #  cpu: 100m
    #     #  memory: 628Mi
    #     requests:
    #     cpu: 50m
    #     memory: 64Mi
    #   priorityClassName: ""

    # ssh:
    #   # Overrides for git over SSH. If you use your own git server, you
    #   # will likely need to provide a host key for it in this field.
    #   known_hosts: ""
    #   # Specify options for SSH key generation.
    #   keygen:
    #     # Specify a key format for key generation.
    #     # RFC4716” (RFC 4716/SSH2 public or private key),
    #     # “PKCS8” (PEM PKCS8 public key) or
    #     # “PEM” (PEM public key).
    #     format: "RFC4716"
    #   secret:
    #     # Annotations for the Secret
    #     annotations: {}
    #   config: ""
    #     # specify the config which would go in /root/.ssh/config file
    #     # for e.g.
    #   # config: |
    #   #   Host github.com
    #   #   ProxyCommand socat STDIO PROXY:<proxyIP>:%h:%p,proxyport=<proxyPort>,proxyauth=<username:password>
    #   #   User git
    #   #   Hostname ssh.github.com
    #   #   Port 443
    #   #   IdentityFile /etc/fluxd/ssh/identity


    # kube:
    #   # Disable KUBECONFIG env var and passing the default config into the Container
    #   # This means you need to provide both on your own, by using extraVars and ExtraVolume(Mounts)
    #   externalConfig: false
    #   # Override for kubectl default config
    #   config: |
    #     apiVersion: v1
    #     clusters: []
    #     contexts:
    #     - context:
    #         cluster: ""
    #         namespace: default
    #         user: ""
    #       name: default
    #     current-context: default
    #     kind: Config
    #     preferences: {}
    #     users: []
    # # For https://github.com/justinbarrick/fluxcloud/
    # # additionalArgs:
    # # - --connect=ws://fluxcloud

    # # The contents of the secret will be defined as environment variables
    # # in the Flux container. Once defined, you can use the variables in your
    # # `git.url`: `https://$(GIT_AUTHUSER):$(GIT_AUTHKEY)@github.com/fluxcd/flux-get-started.git`
    # env:
    #   secretName: ""

    # # Additional environment variables to set
    # extraEnvs: []
    # # extraEnvs:
    # #   - name: FOO
    # #     value: bar

    prometheus:
      enabled: true
      serviceMonitor:
        # Enables ServiceMonitor creation for the Prometheus Operator
        create: false
        interval:
        scrapeTimeout:
        namespace:
        additionalLabels: {}

    # syncGarbageCollection:
    #   enabled: false
    #   dry: false

    # # Enables manifest generation
    # manifestGeneration: false

    # # Add your own init container or uncomment and modify the given example.
    # initContainers: {}
    # #   flux-init:  # <- will be used as container name
    # #     image: "busybox:1.30.1"
    # #     imagePullPolicy: "IfNotPresent"
    # #     command: ['sh', '-c', 'counter=0; until [ "$counter" -ge 30 ]; do if [ -f /tmp/flux-deploy-key/identity ]; then exit 0; else echo waiting for flux deploy key && sleep 1 && counter=$((counter+1)); fi; done; exit 1;']
    # #     volumeMounts:
    # #       - mountPath: /tmp/flux-deploy-key
    # #         name: flux-deploy-key

    # # Additional containers to be added to the flux pod.
    extraContainers:
      - name: fluxcloud
        image: justinbarrick/fluxcloud:v0.3.9
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 3032
        env:
        - name: SLACK_URL
          value: "https://hooks.slack.com/services/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"
        - name: SLACK_CHANNEL
          value: "#kubernetes"
        # Or configure multiple channels
        # (comma separated <channel>=<namespace>) string:
        #  value: "#kubernetes=*,#team=team"
        # Optional: legacy Slack API token
        # - name: SLACK_TOKEN
        #   valueFrom:
        #     secretKeyRef:
        #       key: token
        #       name: slack-token
        - name: SLACK_USERNAME
          value: Flux Deployer
        - name: SLACK_ICON_EMOJI
          value: ":robot_face:"
        - name: GITHUB_URL
          value: "https://github.com/justinbarrick/fluxcloud/"
        - name: LISTEN_ADDRESS
          value: ":3032"

    # # Host aliases to be added to the Flux pod - see < - ip: <https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/>
    # hostAliases: {}
    # # - ip: "127.0.0.1"
    # #    hostnames:
    # #    - "foo.local"
    # #    - "bar.local"
    # #  - ip: "10.1.2.3"
    # #    hostnames:
    # #    - "foo.remote"
    # #    - "bar.remote"

    dashboards:
      # If enabled, flux will create a configmap with a dashboard in json that's going to be picked up by grafana
      # See https://github.com/helm/charts/tree/master/stable/grafana#configuration - `sidecar.dashboards.enabled`
      enabled: true
      # The namespace where the dashboard is deployed, defaults to the installation namespace
      namespace: metrics
      # The prefix of the generated configmaps
      nameprefix: dashboard

---
apiVersion: helm.cattle.io/v1
kind: HelmChart
metadata:
  name: helm-operator
  namespace: kube-system
spec:
  targetNamespace: flux
  chart: helm-operator
  repo: https://charts.fluxcd.io
  valuesContent: |-
    affinity: 
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
            - matchExpressions:
                - key: beta.kubernetes.io/arch
                  operator: In
                  values:
                    - amd64

    # Default values for helm-operator

    nameOverride: ""
    fullnameOverride: ""

    image:
      repository: docker.io/fluxcd/helm-operator
      tag: 1.2.0
      pullPolicy: IfNotPresent
      pullSecret:

    service:
      type: ClusterIP
      port: 3030

    # Include the HelmRelease definition on install
    createCRD: true
    # Limit the operator scope to a single namespace
    allowNamespace:
    # Update dependencies for charts
    updateChartDeps: true
    # Log format can be fmt or json
    logFormat: fmt
    # Log the diff when a chart release diverges
    logReleaseDiffs: false
    # Period on which to reconcile the Helm releases with `HelmRelease` resources
    chartsSyncInterval: "3m"
    # Period on which to update the Helm release status in `HelmRelease` resources
    statusUpdateInterval: "30s"
    # Amount of workers processing releases
    workers: 4

    # Helm versions supported by this operator instance
    helm:
      versions: "v3"

    # Tiller settings
    # If a hostname or IP is given here, that will be combined with the
    # tillerPort and used for connecting to Tiller. Otherwise, the
    # cluster-ip of the `tiller-deploy` service in .tillerNamespace is looked up.
    tillerHost:
    tillerPort: 44134
    tillerNamespace: kube-system
    tls:
      secretName: "helm-client-certs"
      verify: false
      enable: false
      keyFile: "tls.key"
      certFile: "tls.crt"
      caContent: ""
      hostname: ""

    # available options when converting from helm 2 to 3
    convert:
      releaseStorage: "secrets"
      tillerOutCluster: false

    # ADVANCED: Allow for deploying Tiller as a sidecar (restricted to 'localhost' for security reasons).
    # When enabled, either .clusterRole.create should be true or .clusterRole.name should be set to the name of a cluster role granting the required privileges.
    # Please make extra sure you know what you are doing before enabling this. :)
    tillerSidecar:
      enabled: false
      image:
        repository: gcr.io/kubernetes-helm/tiller
        tag: v2.16.1
      storage: secret

    # For charts stored in Helm repositories other than stable
    # mount repositories.yaml configuration in a volume
    configureRepositories:
      enable: false
      volumeName: repositories-yaml
      secretName: flux-helm-repositories
      cacheVolumeName: repositories-cache
      repositories:
        # - name: bitnami
        #   url: https://charts.bitnami.com
        #   username:
        #   password:
        #   caFile:
        #   certFile:
        #   keyFile:

    # Helm plugins to initialize before starting the operator.
    initPlugins:
      enable: false
      cacheVolumeName: plugins-cache
      plugins:
      # - helmVersion: v3
      #   plugin: https://github.com/hypnoglow/helm-s3.git
      #   version: 0.9.2

    # For charts stored in Git repos set the SSH private key secret
    git:
      # Period on which to poll git chart sources for changes
      pollInterval: "5m"
      timeout: "20s"
      # Ref to clone chart from if ref is unspecified in a HelmRelease,
      # empty defaults to `master`
      defaultRef: ""
      # Overrides for git over SSH. If you use your own git server, you
      # will likely need to provide a host key for it in this field.
      ssh:
        # Generate a SSH key named identity: ssh-keygen -q -N "" -f ./identity
        # create a Kubernetes secret: kubectl -n flux create secret generic helm-ssh --from-file=./identity
        # delete the private key: rm ./identity
        # add ./identity.pub as a read-only deployment key in your Git repo where the charts are
        # set the secret name (helm-ssh) below
        secretName: fluxcd-git-deploy
        known_hosts: ""
        # You may want to configure access to multiple repositories via multiple deploy keys
        # flux-helm-operator is configured in /etc/ssh/ssh_config to use for all hosts the file /etc/fluxd/ssh/identity
        # this file is mounted from the above secret
        # all entries in the secret are mounted in the same place /etc/fluxd/ssh/
        # so we can add more entries by providing this config map with a key of config that refer to other files in /etc/fluxd/ssh/
        # e.g. in the above secret create another key for example myprivatehelmrepo
        # in the below config map create a key config and input the following
        #
        # Host *
        # StrictHostKeyChecking yes
        # IdentityFile /etc/fluxd/ssh/identity
        # IdentityFile /var/fluxd/keygen/identity
        # IdentityFile /var/fluxd/keygen/myprivatehelmrepo
        # LogLevel error
        #
        # add the public key to the other repository as a deploy key and enjoy
        configMapName: ""
        # The name of the key in the kubernetes config map specified above
        configMapKey: "config"
      # Global Git configuration See https://git-scm.com/docs/git-config for more details.
      config:
        enabled: false
        secretName: ""
        data: ""
        # data: |
        #   [credential "https://github.com"]
        #           username = foo

    rbac:
      # Specifies whether RBAC resources should be created
      create: true
      # Specifies whether PSP resources should be created
      pspEnabled: false

    serviceAccount:
      # Specifies whether a service account should be created
      create: true
      # Service account annotations
      annotations: {}
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name:

    # If create is `false` the Helm Operator will be restricted to the namespace
    # where it is deployed, and no ClusterRole or ClusterRoleBinding will be created.
    # Additionally, the kubeconfig default context will be set to that namespace.
    clusterRole:
      create: true
      # The name of a cluster role to bind to; if not set and create is
      # true, a name based on fullname is generated
      name:

    kube:
      # Override for kubectl default config
      config: |
        apiVersion: v1
        clusters: []
        contexts:
        - context:
            cluster: ""
            namespace: default
            user: ""
          name: default
        current-context: default
        kind: Config
        preferences: {}
        users: []

    prometheus:
      enabled: true
      serviceMonitor:
        # Enables ServiceMonitor creation for the Prometheus Operator
        create: false
        interval:
        scrapeTimeout:
        namespace:
        additionalLabels: {}

    # Additional environment variables to set
    extraEnvs: []
    # extraEnvs:
    #   - name: FOO
    #     value: bar

    livenessProbe:
      initialDelaySeconds: 1
      periodSeconds: 10
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 3

    readinessProbe:
      initialDelaySeconds: 1
      periodSeconds: 10
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 3

    podAnnotations: {}
    podLabels: {}
    nodeSelector: {}
    tolerations: []
    extraVolumeMounts: []
    extraVolumes: []
    initContainers: []
    resources:
    #  limits:
    #    memory: 1Gi
      requests:
        cpu: 50m
        memory: 64Mi
    # Host aliases allow the modification of the hosts file (/etc/hosts) inside Helm Operator container.
    hostAliases: {}
    # - ip: "127.0.0.1"
    #   hostnames:
    #   - "foo.local"
    #   - "bar.local"
    # - ip: "10.1.2.3"
    #   hostnames:
    #   - "foo.remote"
    #   - "bar.remote"

    priorityClassName: ""

    dashboards:
      # If enabled, helm-operator will create a configmap with a dashboard in json that's going to be picked up by grafana
      # See https://github.com/helm/charts/tree/master/stable/grafana#configuration - `sidecar.dashboards.enabled`
      enabled: false

    securityContext: {}

    containerSecurityContext:
      helmOperator: {}
      tiller: {}

    sidecarContainers:
      - name: fluxcloud
        image: justinbarrick/fluxcloud:v0.3.9
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 3032
        env:
        - name: SLACK_URL
          value: "https://hooks.slack.com/services/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"
        - name: SLACK_CHANNEL
          value: "#kubernetes"
        # Or configure multiple channels
        # (comma separated <channel>=<namespace>) string:
        #  value: "#kubernetes=*,#team=team"
        # Optional: legacy Slack API token
        # - name: SLACK_TOKEN
        #   valueFrom:
        #     secretKeyRef:
        #       key: token
        #       name: slack-token
        - name: SLACK_USERNAME
          value: Flux Deployer
        - name: SLACK_ICON_EMOJI
          value: ":robot_face:"
        - name: GITHUB_URL
          value: "https://github.com/justinbarrick/fluxcloud/"
        - name: LISTEN_ADDRESS
          value: ":3032"

