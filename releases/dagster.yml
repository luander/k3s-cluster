---
apiVersion: helm.fluxcd.io/v1
kind: HelmRelease
metadata:
  name: dagster
  namespace: dagster
spec:
  releaseName: dagster
  chart:
    repository: https://dagster-io.github.io/helm
    name: dagster
    version: 0.10.8
  values:
    ####################################################################################################
    # Dagit: Configuration for the Dagit webserver
    ####################################################################################################
    dagit:
      replicaCount: 1
      # REQUIRED: Dagit image repository and tag to deploy
      image:
        repository: "docker.io/dagster/dagster-celery-k8s"
        tag: "latest"
        pullPolicy: Always

      service:
        type: ClusterIP
        port: 80
        annotations: {}

      # Additional environment variables to set.
      # A Kubernetes ConfigMap will be created with these environment variables. See:
      # https://kubernetes.io/docs/concepts/configuration/configmap/
      #
      # Example:
      #
      # env:
      #   ENV_ONE: one
      #   ENV_TWO: two
      env: {}

      # Additional environment variables can be retrieved and set from ConfigMaps. See:
      # https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables
      #
      # Example:
      #
      # envConfigMaps:
      #   - name: config-map
      envConfigMaps: []

      # Additional environment variables can be retrieved and set from Secrets. See:
      # https://kubernetes.io/docs/concepts/configuration/secret/#use-case-as-container-environment-variables
      #
      # Example:
      #
      # envSecrets:
      #   - name: secret
      envSecrets: []

      # Support Node, affinity and tolerations for Dagit pod assignment. See:
      # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
      # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
      # https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
      annotations: {}
      nodeSelector: {}
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: beta.kubernetes.io/arch
                    operator: In
                    values:
                      - amd64
      tolerations: []
      podSecurityContext: {}
      securityContext: 
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
      resources: {}
      # If you want to specify resources, uncomment the following lines, adjust them as necessary,
      # and remove the curly braces after 'resources:'.
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
      # Liveness probe detects when to restart dagit.
      # https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes
      livenessProbe:
        httpGet:
          path: "/dagit_info"
          port: 80
        # initialDelaySeconds: 60
        periodSeconds: 20
        timeoutSeconds: 3
        successThreshold: 1
        failureThreshold: 3
      # Startup probe (available in kubernetes v1.16+) is used at pod startup. Once it has succeeded,
      # then liveness probe takes over. Current delay is 2 min (10 sec * 12) but can be increased based
      # on workspace load times.
      # If on kubernetes < v1.16, then comment out `startupProbe` lines and comment in
      # `initialDelaySeconds: 60` under `livenessProbe`
      startupProbe:
        httpGet:
          path: "/dagit_info"
          port: 80
        initialDelaySeconds: 1
        periodSeconds: 10
        timeoutSeconds: 3
        successThreshold: 1
        failureThreshold: 12

    ####################################################################################################
    # Compute Log Manager: Configuration for the compute log manager
    ####################################################################################################
    computeLogManager:
      # Type can be one of [
      #   LocalComputeLogManager,
      #   AzureBlobComputeLogManager,
      #   GCSComputeLogManager,
      #   S3ComputeLogManager,
      #   CustomComputeLogManager,
      # ]
      type: LocalComputeLogManager
      config: {}
      ##  Uncomment this configuration if the AzureBlobComputeLogManager is selected
      #   azureBlobComputeLogManager:
      #     storageAccount: ~
      #     container: ~
      #     secretKey: ~
      #     localDir: ~
      #     prefix: ~

      ##  Uncomment this configuration if the GCSComputeLogManager is selected
      #   gcsComputeLogManager:
      #     bucket: ~
      #     localDir: ~
      #     prefix: ~

      ##  Uncomment this configuration if the S3ComputeLogManager is selected
      #   s3ComputeLogManager:
      #     bucket: ~
      #     localDir: ~
      #     prefix: ~
      #     useSsl: ~
      #     verify: ~
      #     verifyCertPath: ~
      #     endpointUrl: ~

      ##  Uncomment this configuration if the CustomComputeLogManager is selected.
      ##  Using this setting requires a custom Dagit image that defines the user specified
      ##  compute log manager in an installed python module.
      #   customComputeLogManager:
      #     module: ~
      #     class: ~
      #     config: {}

    ####################################################################################################
    # User Code Deployments: Configuration for user code containers to be loaded via GRPC server. For
    # each item in the "deployments" list, a K8s Deployment and K8s Service will be created to run the
    # GRPC server that Dagit/Dagster communicates with to get repository information and the current
    # image information. These deployments can be updated independently of Dagit, and Dagit/Dagster
    # will pull the current image for all execution. When using a distributed executor (such as
    # Celery-K8s) for pipeline run, the current image will be queried once and used for all
    # solid executions for that pipeline run. In order to guarantee that all solid executions within a
    # pipeline execution use the same image, we recommend using a unique tag (ie not "latest").
    #
    # All user code will be invoked within the images.
    ####################################################################################################
    userDeployments:
      # Whether launching user deployments is enabled.
      enabled: true
      # List of unique deployments
      deployments:
        - name: "k8s-example-user-code-1"
          image:
            repository: "docker.io/dagster/user-code-example"
            tag: latest
            # Change with caution! If you're using a fixed tag for pipeline run images, changing the
            # image pull policy to anything other than "Always" will use a cached/stale image, which is
            # almost certainly not what you want.
            pullPolicy: Always
          # Arguments to `dagster api grpc`.
          # Ex: "dagster api grpc -m dagster_test.test_project.test_pipelines.repo -a define_demo_execution_repo"
          # would translate to:
          # dagsterApiGrpcArgs:
          #   - "-m"
          #   - "dagster_test.test_project.test_pipelines.repo"
          #   - "-a"
          #   - "define_demo_execution_repo"
          dagsterApiGrpcArgs:
            - "-f"
            - "/example_project/example_repo/repo.py"
          port: 3030

          # Additional environment variables to set.
          # A Kubernetes ConfigMap will be created with these environment variables. See:
          # https://kubernetes.io/docs/concepts/configuration/configmap/
          #
          # Example:
          #
          # env:
          #   ENV_ONE: one
          #   ENV_TWO: two
          env: {}

          # Additional environment variables can be retrieved and set from ConfigMaps. See:
          # https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables
          #
          # Example:
          #
          # envConfigMaps:
          #   - name: config-map
          envConfigMaps: []

          # Additional environment variables can be retrieved and set from Secrets. See:
          # https://kubernetes.io/docs/concepts/configuration/secret/#use-case-as-container-environment-variables
          #
          # Example:
          #
          # envSecrets:
          #   - name: secret
          envSecrets: []

          annotations: {}
          nodeSelector: {}
          affinity:
            nodeAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                nodeSelectorTerms:
                  - matchExpressions:
                      - key: beta.kubernetes.io/arch
                        operator: In
                        values:
                          - amd64
          tolerations: []
          podSecurityContext: {}
          securityContext: 
            runAsUser: 1000
            runAsGroup: 1000
            fsGroup: 1000
          resources: {}
          replicaCount: 1
          # Liveness Probe and Startup Probe are optional. For more configuration docs, see:
          # https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes
          # Note that Startup Probe is only available as a kubernetes v1.16+ feature.
          livenessProbe:
            # If `livenessProbe` has no `exec` field, then the following default will be used:
            # exec:
            #   command: ["dagster", "api", "grpc-health-check", "-p", "{{ $deployment.port }}"]
            initialDelaySeconds: 0
            periodSeconds: 20
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 3
          startupProbe:
            # If `livenessProbe` has no `exec` field, then the following default will be used:
            # exec:
            #   command: ["dagster", "api", "grpc-health-check", "-p", "{{ $deployment.port }}"]
            initialDelaySeconds: 0
            periodSeconds: 10
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 3

          service:
            annotations: {}

    ####################################################################################################
    # Pipeline Run: Configuration for user code containers.
    #
    # Note: This should only be configured when userDeployments are not enabled.
    #
    # `DAGSTER_K8S_PIPELINE_RUN_IMAGE` environment variable will point to the image specified below.
    # The run config for the celery executor can set `job_image` to fetch from environment variable
    # `DAGSTER_K8S_PIPELINE_RUN_IMAGE`, so that celery workers will launch k8s jobs with said image.
    #
    ####################################################################################################
    pipelineRun:
      image:
        repository: "docker.io/dagster/user-code-example"
        tag: "latest"
        pullPolicy: Always

      # Additional environment variables to set.
      # A Kubernetes ConfigMap will be created with these environment variables. See:
      # https://kubernetes.io/docs/concepts/configuration/configmap/
      #
      # Example:
      #
      # env:
      #   ENV_ONE: one
      #   ENV_TWO: two
      env: {}
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: beta.kubernetes.io/arch
                    operator: In
                    values:
                      - amd64
      securityContext: 
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
    ####################################################################################################
    # Scheduler: Configuration for the scheduler
    ####################################################################################################
    scheduler:
      # Type can be one of [
      #   DagsterDaemonScheduler,
      #   K8sScheduler (deprecated),
      #   CustomScheduler,
      #  ]
      type: DagsterDaemonScheduler

    ####################################################################################################
    # Run Launcher: Configuration for run launcher
    ####################################################################################################
    runLauncher:
      # Type can be one of [K8sRunLauncher, CeleryK8sRunLauncher, CustomRunLauncher]
      type: K8sRunLauncher

      config:
        # This configuration will only be used if the K8sRunLauncher is selected
        k8sRunLauncher:
          ## The image to use for the launched Job's Dagster container.
          ## This image should only be specified when user code deployments are disabled. Otherwise,
          ## it will be ignored.
          # image:
          #   repository: ""
          #   tag: ""
          #   pullPolicy: Always

          # The K8s namespace where new jobs will be launched.
          # By default, the release namespace is used.
          jobNamespace: ~

          # Set to true to load kubeconfig from within cluster.
          loadInclusterConfig: true

          # File to load kubeconfig from. Only set this if loadInclusterConfig is false.
          kubeconfigFile: ~

          # Additional environment variables can be retrieved and set from ConfigMaps for the Job. See:
          # https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables
          #
          # Example:
          #
          # envConfigMaps:
          #   - name: config-map
          envConfigMaps: []

          # Additional environment variables can be retrieved and set from Secrets for the Job. See:
          # https://kubernetes.io/docs/concepts/configuration/secret/#use-case-as-container-environment-variables
          #
          # Example:
          #
          # envSecrets:
          #   - name: secret
          envSecrets: []

        # This configuration will only be used if the CeleryK8sRunLauncher is selected
        celeryK8sRunLauncher:
          # The Celery workers can be deployed with a fixed image (no user code included)
          image:
            repository: "docker.io/dagster/dagster-celery-k8s"
            tag: "latest"
            pullPolicy: Always

          # Support overriding the name prefix of Celery worker pods
          nameOverride: "celery-workers"

          # Additional config options for Celery, applied to all queues.
          # For available options, see:
          # https://docs.celeryproject.org/en/stable/userguide/configuration.html
          configSource: {}

          # Additional Celery worker queues can be configured here. When overriding, be sure to
          # provision a "dagster" worker queue, as this is the default queue used by Dagster.
          #
          # Optionally, labels and node selectors can be set on the Celery queue's workers.
          # Specifying a queue's node selector will override any existing node selector defaults.
          workerQueues:
            - name: "dagster"
              replicaCount: 2
              labels: {}
              nodeSelector: {}

          # Additional environment variables to set on the celery/job containers
          # A Kubernetes ConfigMap will be created with these environment variables. See:
          # https://kubernetes.io/docs/concepts/configuration/configmap/
          #
          # Example:
          #
          # env:
          #   ENV_ONE: one
          #   ENV_TWO: two
          env: {}

          # Additional environment variables can be retrieved and set from ConfigMaps. See:
          # https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables
          #
          # Example:
          #
          # envConfigMaps:
          #   - name: config-map
          envConfigMaps: []

          # Additional environment variables can be retrieved and set from Secrets. See:
          # https://kubernetes.io/docs/concepts/configuration/secret/#use-case-as-container-environment-variables
          #
          # Example:
          #
          # envSecrets:
          #   - name: secret
          envSecrets: []

          annotations: {}

          # Sets a node selector as a default for all Celery queues.
          #
          # See:
          # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
          nodeSelector: {}

          # Support affinity and tolerations for Celery pod assignment. See:
          # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
          # https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
          affinity:
            nodeAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                nodeSelectorTerms:
                  - matchExpressions:
                      - key: beta.kubernetes.io/arch
                        operator: In
                        values:
                          - amd64
          tolerations: []
          podSecurityContext: {}
          securityContext: 
            runAsUser: 1000
            runAsGroup: 1000
            fsGroup: 1000

          # Specify resources.
          # Example:
          #
          # resources:
          #   limits:
          #     cpu: 100m
          #     memory: 128Mi
          #   requests:
          #     cpu: 100m
          #     memory: 128Mi
          resources: {}

          # If `livenessProbe` does not contain `exec` field, then we will default to using:
          # exec:
          #   command:
          #     - /bin/sh
          #     - -c
          #     - celery status -A dagster_celery_k8s.app -b {{ include "dagster.celery.broker_url" . }} | grep "${HOSTNAME}:.*OK"
          livenessProbe:
            initialDelaySeconds: 15
            periodSeconds: 10
            timeoutSeconds: 10
            successThreshold: 1
            failureThreshold: 3

        ## Uncomment this configuration will only be used if the CustomRunLauncher is selected.
        ## Using this setting requires a custom Dagit image that defines the user specified
        ## run launcher in an installed python module.
        # customRunLauncher:
        #   module: ~
        #   class: ~
        #   config: {}

    ####################################################################################################
    # PostgreSQL: Configuration values for postgresql
    #
    # https://github.com/kubernetes/charts/blob/master/stable/postgresql/README.md
    #
    # A PostgreSQL database is required to run Dagster on Kubernetes. If postgresql.enabled is marked as
    # false, the PG credentials specified here will still be used, and should point to an external PG
    # database that is accessible from this chart.
    ####################################################################################################
    postgresql:
      # set postgresql.enabled to be false to disable deploy of a PostgreSQL database and use an
      # existing external PostgreSQL database
      enabled: true

      # Used by init container to check that db is running. (Even if enabled:false)
      image:
        registry: "docker.io"
        repository: "library/postgres"
        tag: "9.6.21"
        pullPolicy: IfNotPresent

      
      master:
        affinity:
          nodeAffinity:
            requiredDuringSchedulingIgnoredDuringExecution:
              nodeSelectorTerms:
                - matchExpressions:
                    - key: beta.kubernetes.io/arch
                      operator: In
                      values:
                        - amd64
      slave:
        affinity:
          nodeAffinity:
            requiredDuringSchedulingIgnoredDuringExecution:
              nodeSelectorTerms:
                - matchExpressions:
                    - key: beta.kubernetes.io/arch
                      operator: In
                      values:
                        - amd64

      # set this PostgreSQL hostname when using an external PostgreSQL database
      postgresqlHost: ""

      postgresqlUsername: dagster

      # Note when changing this password (e.g. in test) that credentials will
      # persist as long as the PVCs do -- see:
      # https://github.com/helm/charts/issues/12836#issuecomment-524552358
      postgresqlPassword: dagster

      postgresqlDatabase: dagster

      service:
        port: 5432

    ####################################################################################################
    # RabbitMQ: Configuration values for rabbitmq. Only one of RabbitMQ / Redis should be enabled.
    ####################################################################################################
    rabbitmq:
      enabled: false

      image:
        registry: "docker.io"
        repository: "bitnami/rabbitmq"
        tag: "3.8.12"
        pullPolicy: IfNotPresent

      rabbitmq:
        username: dagster
        password: dagster

      service:
        port: 5672

      # https://github.com/helm/charts/issues/17250#issuecomment-533444837
      volumePermissions:
        enabled: true
        image:
          registry: docker.io
          repository: bitnami/minideb
          tag: stretch
          pullPolicy: IfNotPresent

      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: beta.kubernetes.io/arch
                    operator: In
                    values:
                      - amd64

    ####################################################################################################
    # Redis: Configuration values for Redis. Can be used instead of RabbitMQ.
    ####################################################################################################
    redis:
      # To use redis instead of rabbitmq, set `enabled` to true.
      enabled: false

      # To manage redis via helm, set `internal` to `true`. To use an external redis, set `internal` to `false`.
      # Note: If `internal` is true, then redis pod will be created regardless of `enabled` flag.
      internal: false

      # Redis host URL
      host: ""

      # Redis port
      port: 6379

      # Set DB number for Redis broker DB (default 0)
      brokerDbNumber: 0

      # Set DB number for Redis backend DB (default 0)
      backendDbNumber: 0

    ####################################################################################################
    # Flower: (Optional) The flower web interface for diagnostics and debugging Celery queues & workers
    ####################################################################################################
    flower:
      enabled: true

      image:
        repository: "docker.io/mher/flower"
        tag: "0.9.5"
        pullPolicy: Always

      service:
        type: ClusterIP
        annotations: {}
        port: 5555

      # Support Node, affinity and tolerations for Flower pod assignment. See:
      # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
      # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
      # https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
      annotations: {}
      nodeSelector: {}
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: beta.kubernetes.io/arch
                    operator: In
                    values:
                      - amd64
      tolerations: []
      podSecurityContext: {}
      securityContext: 
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000

      resources: {}
      # If you want to specify resources, uncomment the following lines, adjust them as necessary,
      # and remove the curly braces after 'resources:'.
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi

      # Liveness probe detects when to restart flower.
      # https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes
      livenessProbe:
        tcpSocket:
          port: "flower"
        # initialDelaySeconds: 60
        periodSeconds: 20
        failureThreshold: 3

      # Startup probe (available in kubernetes v1.16+) is used at pod startup. Once it has succeeded,
      # then liveness probe takes over.
      # If on kubernetes < v1.16, then comment out `startupProbe` lines and comment in
      # `initialDelaySeconds: 60` under `livenessProbe`
      startupProbe:
        tcpSocket:
          port: "flower"
        periodSeconds: 10
        failureThreshold: 6

    ####################################################################################################
    # Ingress: (Optional) Create ingresses for Dagit and Flower
    ####################################################################################################
    ingress:
      enabled: true
      annotations:
        kubernetes.io/ingress.class: nginx

      dagit:
        # Ingress hostname for Dagit e.g. dagit.mycompany.com
        # NOTE: Dagit doesn't yet support hosting on a path, e.g. mycompany.com/dagit
        # See: https://github.com/dagster-io/dagster/issues/2073
        host: "dagit.kube.luander.net"

        # Different http paths to add to the ingress before the default dagit path
        # Example:
        #
        # precedingPaths:
        #   - path: "/*"
        #     serviceName: "ssl-redirect"
        #     servicePort: "use-annotation"
        precedingPaths: []

        # Different http paths to add to the ingress after the default dagit path
        # Example:
        #
        # succeedingPaths:
        #   - path: "/*"
        #     serviceName: "ssl-redirect"
        #     servicePort: "use-annotation"
        succeedingPaths: []

      flower:
        # Ingress hostname for Flower e.g. flower.mycompany.com
        host: "flower.kube.luander.net"
        # if path is '/flower', Flower will be accessible at 'mycompany.com/flower'
        # NOTE: do NOT keep trailing slash. For root configuration, set as empty string
        path: ""

        # Different http paths to add to the ingress before the default flower path
        # Example:
        #
        # precedingPaths:
        #   - path: "/*"
        #     serviceName: "ssl-redirect"
        #     servicePort: "use-annotation"
        precedingPaths: []

        # Different http paths to add to the ingress after the default flower path
        # Example:
        #
        # succeedingPaths:
        #   - path: "/*"
        #     serviceName: "ssl-redirect"
        #     servicePort: "use-annotation"
        succeedingPaths: []

    ####################################################################################################
    # Dagster Daemon (Optional) Deploy a daemon for launching queued runs, running partition backfills,
    # and running schedules and sensors.
    #
    # By default, this daemon is included in your deployment and used to run schedules and sensors.
    # Setting `enabled` to false will stop the daemon from being included in your deployment.
    #
    # To run schedules using K8sScheduler and K8s CronJobs instead of in the daemon, set `k8sEnabled`
    # under the `scheduler` key above to true.
    #
    # Setting `enabled` in `queuedRunCoordinator` allows you to set limits on the total number of runs
    # that can execute at once.
    #
    # Setting `enabled` in `backfill` allows you to schedule backfills asynchronously instead of in a
    # dagit request (which might aggressively tie up resources for large backfill jobs).
    ####################################################################################################
    dagsterDaemon:
      enabled: true

      image:
        repository: "docker.io/dagster/dagster-celery-k8s"
        tag: "latest"
        pullPolicy: Always

      queuedRunCoordinator:
        enabled: false
        config: {}

      backfill:
        enabled: false

      # Additional environment variables to set.
      # A Kubernetes ConfigMap will be created with these environment variables. See:
      # https://kubernetes.io/docs/concepts/configuration/configmap/
      #
      # Example:
      #
      # env:
      #   ENV_ONE: one
      #   ENV_TWO: two
      env: {}

      # Additional environment variables can be retrieved and set from ConfigMaps. See:
      # https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables
      #
      # Example:
      #
      # envConfigMaps:
      #   - name: config-map
      envConfigMaps: []

      # Additional environment variables can be retrieved and set from Secrets. See:
      # https://kubernetes.io/docs/concepts/configuration/secret/#use-case-as-container-environment-variables
      #
      # Example:
      #
      # envSecrets:
      #   - name: secret
      envSecrets: []

      annotations: {}
      nodeSelector: {}
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: beta.kubernetes.io/arch
                    operator: In
                    values:
                      - amd64
      tolerations: []
      podSecurityContext: {}
      securityContext: 
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
      resources: {}

      livenessProbe:
        exec:
          command:
            - "dagster-daemon"
            - "liveness-check"
        # initialDelaySeconds: 60
        periodSeconds: 30
        failureThreshold: 3
        timeoutSeconds: 3
      # Startup probe (available in kubernetes v1.16+) is used at pod startup. Once it has succeeded,
      # then liveness probe takes over. Current delay is 2 min (10 sec * 12) but can be increased based
      # on workspace load times.
      # If on kubernetes < v1.16, then comment out `startupProbe` lines and comment in
      # `initialDelaySeconds: 60` under `livenessProbe`
      startupProbe:
        exec:
          command:
            - "dagster-daemon"
            - "liveness-check"
        periodSeconds: 10
        failureThreshold: 12
        timeoutSeconds: 3

    ####################################################################################################
    # busybox: Configuration for the busybox image used to check connections
    ####################################################################################################
    busybox:
      image:
        repository: "docker.io/busybox"
        tag: "1.28"
        pullPolicy: "IfNotPresent"

    ####################################################################################################
    # Extra Manifests: (Optional) Create additional k8s resources within this chart
    ####################################################################################################
    extraManifests:
    #  # Set default container resource requests/limits for the namespace
    #  #   * To override these for dagster system containers; edit the resources sections of
    #  #     this values yaml -  eg: dagit.resources & celery.resources
    #  #   * To override these in solid execution containers; add a @solid(tag=) similar to:
    #  #      { "dagster-k8s/config": { "container_config": { "resources": {...
    #  - apiVersion: v1
    #    kind: LimitRange
    #    metadata:
    #      name: default-container-resources
    #    spec:
    #      limits:
    #        - default:
    #            cpu: 250m
    #            memory: 512Mi
    #          defaultRequest:
    #            cpu: 100m
    #            memory: 256Mi
    #          type: Container
    #  # Example 2:
    #  - apiVersion: cloud.google.com/v1beta1
    #    kind: BackendConfig
    #    metadata:
    #      name: "{{ .Release.Name }}-backend-config"
    #      labels:
    #      {{- include "dagster.labels" . | nindent 6 }}
    #      spec:
    #        securityPolicy:
    #          name: "gcp-cloud-armor-policy-test"

    serviceAccount:
      create: true